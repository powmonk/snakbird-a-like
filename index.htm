<!DOCTYPE html>
<html lang="en"> 
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>Test Game</title>
		<style type="text/css">
			canvas {
				width: 1024px;
				height: 648px;
				
				margin-left: 0px;
				margin-top:  0px; 
			}
		</style>
	</head>
	<body>
		<div>
		<canvas id="levelCanvas" width="1024" height="648" style="border:0px solid #FF0000;">
		Guttted mush, your browser's pants.
		</canvas> 
		</div>
		
		<!-- We need to load images this way for the LMS to load them in the right folder-->
		<img id="floor_tile_00" width="32" height="32" src="images/floor_tile_00.png" alt="floor_tile_00" style="display:none">
		<img id="floor_tile_01" width="32" height="32" src="images/floor_tile_01.png" alt="floor_tile_01" style="display:none">
		<img id="hit_box" width="32" height="32" src="images/hit_box.png" alt="hit_box"style="display:none">
		<img id="deano" width="32" height="64" src="images/deano_walk.gif" alt="it's only flippin' Deano!" style="display:none">
		<img id="deano_walk" width="32" height="64" src="images/deano_spritesheet.png" alt="it's only flippin' Deano! Now he's only bloody walkin'!" style="display:none">
		<img id="crab_apple" width="64" height="84" src="images/apple_rick_large.png" alt="uhhh..." style="display:none">
		<img id="coin" width="320" height="32" src="images/coin_spritesheet.png" alt="coin" style="display:none">
		<img id="mountains" width="1728" height="648" src="images/mountains_3d.png" alt="mountains" style="display:none">
		<img id="hills" width="5000" height="648" src="images/hills_3d.png" alt="hills" style="display:none">
		<img id="sky" width="800" height="648" src="images/sky.jpg" alt="sky" style="display:none">
		<img id="cloud" width="766" height="167" src="images/cloud.png" alt="cloud" style="display:none">
		<img id="dead" src="images/dead.png" alt="dead" style="display:none">
		<img id="apple" src="images/apple.png" alt="dead" style="display:none">
		<img id="santa_head_up" src="images/santa_head_up.png" alt="santa" style="display:none">
		<img id="santa_torso_up" src="images/santa_torso_up.png" alt="santa" style="display:none">
		<img id="santa_corner" src="images/santa_torso_corner.png" alt="santa" style="display:none">
		<img id="santa_feet_up" src="images/santa_feet_up.png" alt="santa" style="display:none">
		<img id="log_tile" src="images/log.png" alt="logTile" style="display:none">
		<img id="board_tile" src="images/boards.png" alt="boardTile" style="display:none">
		<script>
		
		var COLOR  = { BLACK: '#000000', YELLOW: '#ECD078', SKY: '#8888FF', PINK: '#C02942', PURPLE: '#542437', GREY: '#333', SLATE: '#53777A', WHITE: '#FFFFFF' },
			COLORS = [ COLOR.BLACK, COLOR.YELLOW, COLOR.SKY, COLOR.PINK, COLOR.PURPLE, COLOR.GREY, COLOR.WHITE ];

		var MAP      = { tileX: 32, tileY: 20 }, // the size of the map (in tiles)
			TILE     = 32,                 	// the size of each tile (in game pixels)
			METER    = TILE,               	// abitrary choice for 1m
			//GRAVITY  = METER * 9.8 * 6,   // very exagerated gravity (6x)
			GRAVITY  = 7,    				//I'm too lazy to work out the physics so I'm just using fixed values for now
			MAXDX    = METER * 20,         	// max horizontal speed (20 tiles per second)
			MAXDY    = METER * 60,         	// max vertical speed   (60 tiles per second)
			//ACCEL    = MAXDX * 2,         // horizontal acceleration -  take 1/2 second to reach maxdx
			ACCEL    = 5,          			//I'm too lazy to work out the physics so I'm just using fixed values for now
			FRICTION = MAXDX * 6,          	// horizontal friction     -  take 1/6 second to stop from maxdx
			JUMP     = METER * 1500;       	// (a large) instantaneous jump impulse
			KEY      = { SPACE: 32, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40 };
			

		var canvas   = document.getElementById('levelCanvas'),
			ctx      = canvas.getContext('2d'),
			width    = canvas.width  = MAP.tileX * TILE,
			height   = canvas.height = MAP.tileY * TILE;
			
		var t2p      = function(t)     {return t*TILE;                  },
			p2t      = function(p)     {return Math.floor(p/TILE);      },
			cell     = function(x,y)   {return tcell(p2t(x),p2t(y));    },
			tcell    = function(tx,ty) {return cells[tx + (ty*MAP.tw)]; };
		
		var floor_00 		= document.getElementById('floor_tile_00');
		var floor_01 		= document.getElementById('floor_tile_01');
		var hitbox 			= document.getElementById('hit_box');
		var playerImage 	= document.getElementById('deano');
		var playerWalk 		= document.getElementById('deano_walk');
		var badAppleWalk 	= document.getElementById('crab_apple');
		var coinImage 		= document.getElementById('coin');
		var deadImage 		= document.getElementById('dead');
		var mountains 		= document.getElementById('mountains');
		var hills 			= document.getElementById('hills');
		var sky 			= document.getElementById('sky');
		var cloud 			= document.getElementById('cloud');
		var apple 			= document.getElementById('apple');
		var santa_head_up 	= document.getElementById('santa_head_up');
		var santa_torso_up 	= document.getElementById('santa_torso_up');
		var santa_corner 	= document.getElementById('santa_corner');
		var santa_feet_up 	= document.getElementById('santa_feet_up');
		var log_tile 		= document.getElementById('log_tile');
		var board_tile 		= document.getElementById('board_tile');
		var coincount		= 0;
		var frameDelay 		= 0;
		var levelX 			= 0;
		var cloudX 			= 1024;
		
		var player 			= {	image:hit_box, x:[], y:[], moving:false, face:"left", length:3, alive:true,frame:0, height:64, width:32, jump:false, fall: false};
		var santa			= {image:coin, x:1, y:1, length:2, alive:true};
		var clouds 			= {x:0,y:0,speed:10};

		var level001 = [
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,02,-1,-2,-1,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,-2,-1,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-1,-1,-2,-2,-2,-2,-2,02,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,02,02,02,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,01,00,01,00,01,00,01,00,01,02,-1,-2,-2,01,-2,01,-2,-2,-1,02,00,00,00,00,00,00,00,00,00,00,00],
			[01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01]
		];		
		var levelXSize 		= t2p(level001[1].length);

				
		if (!window.requestAnimationFrame) {
			window.requestAnimationFrame = window.webkitRequestAnimationFrame || 
				window.mozRequestAnimationFrame    || 
				window.oRequestAnimationFrame      || 
				window.msRequestAnimationFrame     || 
				function(callback, element) {
					window.setTimeout(callback, 1000 / 60);
			}
		}
		

		
		function initPlayer(){
			//player.x = 3 * TILE;
			//player.y = 14 * TILE;
			
			for(i=0;i<player.length;i++){
				player.x[i] = 13;
				player.y[i] = i;
			};
			
			
			
		};
		
		initPlayer();
		
		function drawTile(sourceImage, x, y){
			if(sourceImage.complete){
				ctx.drawImage(sourceImage, x, y)
			}else{
				ctx.fillStyle = COLOR.PINK;
				ctx.fillRect(x, y, TILE, TILE);
			}
		};
		

		function getAnimStep(){
			if(frameDelay<6){
				frameDelay++;
				return false;
			}else{
				frameDelay = 0;
				return true;
			}
		}
		
		function drawCoin(ctx, x=32, y=32){
			if(coincount < 9 ){
				ctx.drawImage(coinImage, 32*coincount,0,32,32,x,y,32,32);
				if(getAnimStep()){
					coincount++;
				}
			}else{
				coincount=0;
			};		
		};

					
					
		function updateEntity(entity, ctx){
			if(entity.y > height){
				entity.alive = false;
			};
			
			if(entity.alive){
				if(entity === player){
					movePlayer();
				};
				
				if(entity.moving){
					if(entity.frame<entity.frameCount){
						if(getAnimStep())
							entity.frame++;
					}else{
						entity.frame=0;
					};
				}else{
					entity.frame=0;
				};
				
				
				
				switch(entity.face){
					//case "left":	
					//	ctx.drawImage(entity.image, entity.width*entity.frame,0,entity.width,entity.height,entity.x,entity.y,entity.width,entity.height);
					// 	break;
					//case "right":	
					//	ctx.drawImage(entity.image, entity.width*entity.frame,0,entity.width,entity.height,entity.x,entity.y,entity.width,entity.height);
					//	//mirrorImage(ctx, entity, true, false, entity.frame);
					//	break;
					//case "down":	
					//	ctx.drawImage(entity.image, entity.width*entity.frame,0,entity.width,entity.height,entity.x,entity.y,entity.width,entity.height);
					//	break;
					//case "up":		
					//	ctx.drawImage(entity.image, entity.width*entity.frame,0,entity.width,entity.height,entity.x,entity.y,entity.width,entity.height);
					//	break;		
					case "left":	
					case "right":	
					case "down":	
					case "up":
						drawPlayer();
						//for(i=0;i<entity.length;i++){
						//	ctx.drawImage(entity.image, entity.width*entity.frame,0,entity.width,entity.height,entity.x[i]*32,entity.y[i]*32,entity.width,entity.height);
						//};
						break;									
				};
				
			};
		};	
				
		function drawPlayer(){
			for(i=0;i<player.length;i++){
				switch(i){
					
					//head
					case 0:
						//rightway up
						if(player.y[1] === player.y[i]+1){
							ctx.drawImage(santa_head_up, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);	
							break;
						}
						
						//upside down
						if(player.y[1] === player.y[i]-1){
							//ctx.drawImage(santa_head_up, player.width*player.frame,0,player.width,player.height,player.x[i]*32,player.y[i]*32,player.width,player.height);
							//mirrorImage(ctx, entity, true, false, entity.frame);
						
							flipImage(santa_head_up, ctx, 'down', t2p(player.x[i]),t2p(player.y[i]));
							break;
						}
						
						//face left
						if(player.x[1] === player.x[i]+1){
							//rotateImage(santa_head_up, player.x[i]*32, player.y[i]*32, 1, 45);
							flipImage(santa_head_up, ctx, 'left', t2p(player.x[i]),t2p(player.y[i]));
							break;
						}

						//face right
						if(player.x[1] === player.x[i]-1){
							//rotateImage(santa_head_up, player.x[i]*32, player.y[i]*32, 1, 45);
							flipImage(santa_head_up, ctx, 'right', t2p(player.x[i]),t2p(player.y[i]));
							break;
						}

						ctx.drawImage(santa_head_up, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);	
						
						//drawTile(santa_head_up, player.x[i], player.y[i]*32);
						break;
						
					//feet
					case player.length - 1:
						//upside down
						if(player.y[i-1] === player.y[i]+1){
							//ctx.drawImage(santa_head_up, player.width*player.frame,0,player.width,player.height,player.x[i]*32,player.y[i]*32,player.width,player.height);
							//mirrorImage(ctx, entity, true, false, entity.frame);
							flipImage(santa_feet_up, ctx, 'down', t2p(player.x[i]),t2p(player.y[i]));
							break;
						}
						
						//right
						if(player.x[i-1] === player.x[i]+1){
							flipImage(santa_feet_up, ctx, 'right', player.x[i]*32,player.y[i]*32);
							break;
						};
						
						//left
						if(player.x[i-1] === player.x[i]-1){
							flipImage(santa_feet_up, ctx, 'left', player.x[i]*32,player.y[i]*32);
							break;
						};
												
						ctx.drawImage(santa_feet_up, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);
						//drawTile(santa_feet_up, player.x[i], player.y[i]);
						break;
					//torso
					default:
						let top 	= false;
						let bottom 	= false;
						let left 	= false;
						let right 	= false;

						//console.log("y[i]: " + (player.y[i]-1));
						//console.log("y[i-1]: " +player.y[i-1]);
						
						if(player.y[i]-1 == player.y[i-1])
							top=true;
						if(player.y[i]+1 == player.y[i+1])
							bottom=true;
						if(player.x[i]-1 == player.x[i-1])
							left=true;
						if(player.x[i]+1 == player.x[i+1])
							right=true;
						//
						////if(locations != ("top:"+top+", bottom:"+bottom+", left:"+left+", right:"+right))
						console.log("i:"+i+", top:"+top+", bottom:"+bottom+", left:"+left+", right:"+right);
						////
						////var locations = "top:"+top+", bottom:"+bottom+", left:"+left+", right:"+right;
					
						let isVertical 		= false;
						let isHorizontal 	= false;
						let isCorner 		= false;
						//we need to check if this is a corner piece
						//first check if it connects the trailing and leading pieces vertically
						if(player.x[i-1] == player.x[i] && player.x[i+1] == player.x[i]){
							isVertical = true;
						}
						
						//then check if it connects them horizontally
						if(player.y[i-1] == player.y[i] && player.y[i+1] == player.y[i]){
							isHorizontal = true;
						}
						
						//if it doesn't then it's a corner piece
						isCorner = !isVertical && !isHorizontal ? true:false;
						
						if(isHorizontal){
							flipImage(santa_torso_up, ctx, 'right', t2p(player.x[i]),t2p(player.y[i]));
							break;
						};
						
						if(isCorner){
							if(top == true && right == true){
								//this is top right
								flipImage(santa_corner, ctx, 'right', t2p(player.x[i]),t2p(player.y[i]));
								break;
							}
						
							//if(top && left){
							//	//this is top left
							//	ctx.drawImage(santa_corner, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);
							//	break;
							//}
							//if(top && right){
							//	flipImage(santa_corner, ctx, 'down', t2p(player.x[i]),t2p(player.y[i]));
							//	break;
							//}
							//if(top && left)
							//	ctx.drawImage(santa_corner, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);
							//if(bottom && left)
							//	flipImage(santa_corner, ctx, 'down', t2p(player.x[i]),t2p(player.y[i]));
								
							break;
						}
						
						////now we check what type of corner piece to render
						//if(isCorner){
						//	if(
						//	
						//};
						
						ctx.drawImage(santa_torso_up, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);
						//drawTile(santa_torso_up, player.x[i], player.y[i]);
						break;
				};
			};

		};
		
		function flipImage(image, ctx, flip, x, y) {
				
			ctx.save(); // Save the current state
			
			switch(flip){
				case 'right':
					rotation = 90;
					ctx.translate(t2p(1),t2p(0));
					rotation = rotation / 180 * Math.PI;
					ctx.rotate(rotation);
					ctx.drawImage(image, y, x*-1, TILE, TILE); // draw the image
				case 'left':
					rotation = 90;
					ctx.translate(t2p(1),t2p(0));
					rotation = rotation / 180 * Math.PI;
					ctx.rotate(rotation);
					ctx.drawImage(image, y, x*-1, TILE, TILE); // draw the image
				
				case 'down':
					var scaleH =  1; // Set horizontal scale to -1 if flip horizontal
					var	scaleV = -1; // Set verical scale to -1 if flip vertical
					var posX = t2p(-1) ; // Set x position to -100% if flip horizontal 
					var posY = t2p(-1);// Set y position to -100% if flip vertical
					ctx.scale(-1, -1); // Set scale to flip the image
			        ctx.drawImage(image, posX - x, posY - y, TILE, TILE); // draw the image

			};
					
			
				//ctx.scale(scaleH, scaleV); // Set scale to flip the image
				//ctx.drawImage(image,posX + x, posY - y, TILE, TILE); // draw the image
			//ctx.drawImage(image, player.width,0,32,32,player.x[0]*32,player.y[0]*32,player.width,player.height);
			ctx.restore(); // Restore the last saved state
		};
		
		

		function mirrorImage(ctx, entity, horizontal, vertical, frame){
		
			var image = entity.image;
			let x = entity.x;
			let y = entity.y;
			
			ctx.save();  // save the current canvas state
			
			var a = horizontal ? -1 : 1; // set the direction of x axis
			var b = 0; 
			var c = 0;
			var d = vertical ? -1 : 1; //// set the direction of y axis
//			var e = x + horizontal ? image.width : 0; // set the x origin
//			var f = y + vertical ? image.height : 0 ; // set the y origin
			var e = horizontal ? x + entity.width : x; // set the x origin
			var f = vertical   ? y + entity.height: y; // set the y origin
			
			
			ctx.setTransform(a,b,c,d,e,f);
			//ctx.drawImage(image,0,0);
			ctx.drawImage(image, entity.width*frame,0,entity.width,entity.height,0,0,entity.width,entity.height);
			ctx.restore(); // restore the state as it was when this function was called
		};		
		
	
		function timestamp() {
		  if (window.performance && window.performance.now)
			return window.performance.now();
		  else
			return new Date().getTime();
		};
		
		var fps  = 60,
			step = 1/fps,
			dt   = 0,
			now, last = timestamp(),
			cells = [];
			
		function bound(x, min, max) {
			return Math.max(min, Math.min(max, x));
		};			

		function frame() {
		  now = timestamp();
		  dt = dt + Math.min(1, (now - last) / 1000);
		  while(dt > step) {
			dt = dt - step;
			update(step);
		  }
		  last = now;
		  requestAnimationFrame(frame, canvas);
		}

		frame(); // start the first frame
		
		function invertNumber(numberToInvert){
			return numberToInvert * -1;
		};	

		//Create rain array
		var rain = [];
		
		var showerSize = 60;
		
		//Create a loop which add objects to the rain array
		function initRain(){
			for (i=0;i<showerSize;i++)
				rain.push({
					x:Math.floor(Math.random() * 1500), 
					y:Math.floor(Math.random() * 648), 
					xDrift:Math.floor(Math.random() * 200), 
					driftDir:Math.floor(Math.random()), 
				});
		};
		
		//initRain();
		
		function droplet(getSet, position, x, y){
			switch(getSet){
				case 'set':
					rain[position].x = x;
					rain[position].y = y;
					return;
				case 'get':
					//x = drop[position].x;
					//y = drop[position].y;
					return [rain[position].x, rain[position].y];
			};
		};

		
		function drawRain(ctx){
			for(i=0;i<showerSize;i++){
				ctx.fillStyle = 'rgba('+255+','+255+','+255+',1)';
				//ctx.fillRect(rain[i].x, rain[i].y, 8,8);
				ctx.beginPath();
				ctx.arc(rain[i].x + rain[i].xDrift, rain[i].y, 4, 0, 2 * Math.PI, false);
				ctx.fill();
				
				if(rain[i].xDrift >= 200){
					rain[i].driftDir = 0;
				}
				
				if(rain[i].xDrift <= 0){
					rain[i].driftDir = 1;
				}
				
				
				rain[i].xDrift += rain[i].driftDir === 1 ? 1:-1;
				
					
				if(rain[i].y<648 && rain[i].x>0){
					rain[i].y+= 0.3;
					rain[i].x-= 0.5;
				}else{
					rain[i].y = 0;
					rain[i].x = Math.floor(Math.random() * 1500);
				};
			};
		};
			
				
		function drawLevel(ctx){
			//These two variable set the portions of the screen that trigger scrolling of the level
			var upperBound = TILE * 22;
			var lowerBound = TILE * 10;
			
			//OPEN| These chunks sets the level X position and player X position for scrolling
			if(player.x > upperBound && levelX < levelXSize){
				levelX-=ACCEL;
				player.x = upperBound;
			};

			if(player.x < lowerBound && levelX < 0){
				levelX+=ACCEL;
				player.x = lowerBound;
			};
			//CLOSE|
			
			arrayX = p2t(invertNumber(levelX));

			//Draw Sky
			for(y=0;y<MAP.tileY;y++){
				for(x=0;x<MAP.tileX + 2;x++){
					if(y >= 0 && y < height){ 
						let drawX = levelX +t2p(x+arrayX);
						
						//levelX+((x+arrayX)*8)
						
						let drawY = t2p(y);
						
						//console.log(p2t(x + levelX));
						let character = level001[y][x];
						switch(character){
							case -2:
								drawTile(board_tile, drawX, drawY);
								break;
								
							default:
								ctx.fillStyle = COLOR.SKY;
								ctx.fillRect(drawX, drawY, TILE, TILE);
								break;
						
						};
					};
				};
			};
			
			drawTile(sky, 0, 0);
			
			//Draw Background (This is a mess)
			//TODO make this bit sane
			
			var bg_width = 5000;
			
			//drawTile(mountains, levelX/4, 0);
			//drawTile(mountains, levelX/4+bg_width, 0);
			//drawTile(mountains, levelX/4+bg_width+bg_width, 0);
			//drawTile(hills, levelX/1.5, 0);
			//drawTile(hills, levelX/1.5+bg_width, 0);
			//drawTile(hills, levelX/1.5+bg_width+bg_width, 0);
			//drawTile(hills, levelX/1.5+bg_width+bg_width+bg_width, 0);
			//drawTile(hills, levelX/1.5+bg_width+bg_width+bg_width+bg_width, 0);
			//
			//
			//drawRain(ctx);

			//Draw Clouds
			//drawTile(cloud, --cloudX, 20);
			if(cloudX < -766){
				cloudX = 1300;
			};
			
			
			
			//Draw Foreground
			for(y=0;y<MAP.tileY;y++){
				for(x=0;x<MAP.tileX + 2;x++){
					if(y >= 0 && y < height){ 
						let drawX = levelX +t2p(x+arrayX);
						
						//levelX+((x+arrayX)*8)
						
						let drawY = t2p(y);
						
						//console.log(p2t(x + levelX));
						let character = level001[y][x+arrayX];
						switch(character){
							//default:
							//	ctx.fillStyle = COLOR.SKY;
							//	ctx.fillRect(drawX, drawY, TILE, TILE);
							//	break;
							case 1:
								if(drawY > 0 && level001[y-1][x+arrayX] === 0 ){
									drawTile(floor_00, drawX, drawY);
								}else{
									drawTile(floor_01, drawX, drawY);
								};
								break;
							case 2:								
								drawTile(board_tile, drawX, drawY);
								drawTile(log_tile, drawX, drawY);
								break;
							case -2:
								drawTile(board_tile, drawX, drawY);
								break;
							case -1:
								drawTile(board_tile, drawX, drawY);
								drawTile(apple, drawX, drawY);
								break;
							case -3:
								ctx.fillStyle = COLOR.SKY;
								ctx.fillRect(drawX, drawY, TILE, TILE);
								drawCoin(ctx, drawX, drawY);
								break;
						};
					};
				};
			};
		};

		var inLMS = true;
		
		try{ trivPageScope; }
		catch(e) {
			if(e.name == "ReferenceError") {
				inLMS = false;
				console.log("not in lectora");
				document.addEventListener('keydown', function(ev) { return onkey(ev, ev.keyCode, true);  }, false);
				document.addEventListener('keyup',   function(ev) { return onkey(ev, ev.keyCode, false); }, false);
			};
		};
			
		if(inLMS){
			console.log("in lectora");
			var thePage = document.getElementById('pageDIV');
			console.log("does the page work? = " + thePage);
			thePage.addEventListener('keydown', function(ev) { return onkey(ev, ev.keyCode, true);  }, false);
			thePage.addEventListener('keyup',   function(ev) { return onkey(ev, ev.keyCode, false); }, false);

		};
		
		function onkey(ev, key, down) {
			if(down){
				switch(key) {
					case KEY.LEFT:  player.moving = true; player.face = "left";	/*console.log("you pressed the left key, player x:"+player.x)*/	;break;
					case KEY.RIGHT: player.moving = true; player.face = "right";/*console.log("you pressed the right key, player x:"+player.x)*/;break;
					case KEY.UP: 	player.moving = true; player.face = "up";	/*console.log("you pressed the left key, player x:"+player.x)*/	;break;
					case KEY.DOWN: 	player.moving = true; player.face = "down";	/*console.log("you pressed the right key, player x:"+player.x)*/;break;
				};
			}else{
				player.moving =  false;
			};
		};
				
		function update(dt){
			//drawNoise();
			drawLevel(ctx, dt);
			updateEntity(player, ctx)
			//for(i=0;i<baddies.length;i++)
			//	updateEntity(baddies[i], ctx)
		};


		function aldronKeyUp(){
			player.moving = false;
		};
		
		function isFalling(){
			//Set falling to true, then check for any supporting tiles
			player.falling = true;
			
			
			//if there are any tiles under the snake then it isn't falling
			for(i=0;i<player.length;i++){
				//console.log(player.x[i]);
				//console.log(player.y[i] + 1);
				if(level001[player.y[i] + 1][player.x[i]] > 0){
					player.falling=false;
				};
				
			};
			
			if(player.falling){
				for(i=0;i<player.length;i++){
					player.y[i]+=1;
				};
			};
			
			return player.falling;
		
		};
		
		function tail(){
			for(i=player.length+1;i>0;i--){
				player.x[i] = player.x[i-1];
				player.y[i] = player.y[i-1];
			};
		};

		function isTileTail(y,x){
			for(i=player.length-1;i>0;i--){
				if( player.x[i] === x && player.y[i] === y)
					return true;
			};
			return false;
		};
		
		function playerCanMove(){
			switch(player.face){
				case "left":
					if(level001[player.y[0]][player.x[0] - 1] < 1 && !isTileTail(player.y[0], player.x[0] - 1)){
						return true;
					};
					break;
				case "right":	
					if(level001[player.y[0]][player.x[0] + 1] < 1 && !isTileTail(player.y[0], player.x[0] + 1)){
						return true;
					}; 
					break;
				case "down":
					if(level001[player.y[0]+1][player.x[0]] < 1 && !isTileTail(player.y[0]+1, player.x[0])){
						return true;
					};
					break;
				case "up":		
					if(level001[player.y[0]-1][player.x[0]] < 1 && !isTileTail(player.y[0]-1, player.x[0])){
						return true;
					};
					break;
			};
			return false;
			
		};
		
		function movePlayer(){	

			isFalling();
		
			if(player.moving &&  !isFalling()){


				switch(player.face){
					case "left":
						if(playerCanMove()){
							tail();
							player.x[0]-=1; 
						};
						break;
					case "right":	
						if(playerCanMove()){
							tail();
							player.x[0]+=1;							
						}; 
						break;
					case "down":
						if(playerCanMove()){
							tail();player.y[0]+=1; break;
						};
					case "up":
						if(playerCanMove()){
							tail();player.y[0]-=1; break;
						};
				};
				
				
				
				player.moving = false;
			};
			if(level001[player.y[0]][player.x[0]] === -1){
				player.length+=1;
				level001[player.y[0]][player.x[0]] = -2;
			};
			
		};
		
		
		</script>
	</body>
</html>