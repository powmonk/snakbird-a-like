<!DOCTYPE html>
<html lang="en"> 
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>Santapede</title>
		<style type="text/css">
			canvas {
				width: 1024px;
				height: 648px;
				
				margin-left: 0px;
				margin-top:  0px; 
			}
			
		</style>
	</head>
	<body>
		<div>
		<canvas id="levelCanvas" width="1024" height="648" style="border:0px solid #FF0000;">
		Guttted mush, your browser's pants.
		</canvas> 
		</div>
		
		<!-- We need to load images this way for the LMS to load them in the right folder-->
		<img id="level000" width="32" height="20" src="level000.png" alt="level000" style="display:none">

		<img id="floor_tile_00" width="32" height="32" src="images/floor_tile_00.png" alt="floor_tile_00" style="display:none">
		<img id="floor_tile_01" width="32" height="32" src="images/floor_tile_01.png" alt="floor_tile_01" style="display:none">
		<img id="hit_box" width="32" height="32" src="images/hit_box.png" alt="hit_box"style="display:none">
		<img id="deano" width="32" height="64" src="images/deano_walk.gif" alt="it's only flippin' Deano!" style="display:none">
		<img id="deano_walk" width="32" height="64" src="images/deano_spritesheet.png" alt="it's only flippin' Deano! Now he's only bloody walkin'!" style="display:none">
		<img id="crab_apple" width="64" height="84" src="images/apple_rick_large.png" alt="uhhh..." style="display:none">
		<img id="coin" width="320" height="32" src="images/coin_spritesheet.png" alt="coin" style="display:none">
		<img id="mountains" width="1728" height="648" src="images/mountains_3d.png" alt="mountains" style="display:none">
		<img id="hills" width="5000" height="648" src="images/hills_3d.png" alt="hills" style="display:none">
		<img id="sky" width="800" height="648" src="images/sky.jpg" alt="sky" style="display:none">
		<img id="cloud" width="766" height="167" src="images/cloud.png" alt="cloud" style="display:none">
		<img id="dead" src="images/dead.png" alt="dead" style="display:none">
		<img id="apple" src="images/apple.png" alt="dead" style="display:none">
		<img id="santa_head_up" src="images/santa_head_up.png" alt="santa" style="display:none">
		<img id="santa_arms_up" src="images/santa_arms_up.png" alt="santa" style="display:none">
		<img id="santa_torso_up" src="images/santa_torso_up.png" alt="santa" style="display:none">
		<img id="santa_corner" src="images/santa_torso_corner.png" alt="santa" style="display:none">
		<img id="santa_feet_up" src="images/santa_feet_up.png" alt="santa" style="display:none">
		<img id="log_tile" src="images/log.png" alt="logTile" style="display:none">
		<img id="board_tile" src="images/boards.png" alt="boardTile" style="display:none">
		<script>
		
		var COLOR  = { BLACK: '#000000', YELLOW: '#ECD078', SKY: '#8888FF', PINK: '#C02942', PURPLE: '#542437', GREY: '#333', SLATE: '#53777A', WHITE: '#FFFFFF' },
			COLORS = [ COLOR.BLACK, COLOR.YELLOW, COLOR.SKY, COLOR.PINK, COLOR.PURPLE, COLOR.GREY, COLOR.WHITE ];

		var MAP      	= { tileX: 32, tileY: 20 }, // the size of the map (in tiles)
			TILE     	= 32,                 	// the size of each tile (in game pixels)
			METER    	= TILE,               	// abitrary choice for 1m
			//GRAVITY  	= METER * 9.8 * 6,   // very exagerated gravity (6x)
			GRAVITY 	= 7,    				//I'm too lazy to work out the physics so I'm just using fixed values for now
			MAXDX   	= METER * 20,         	// max horizontal speed (20 tiles per second)
			MAXDY   	= METER * 60,         	// max vertical speed   (60 tiles per second)
			//ACCEL 	  = MAXDX * 2,         // horizontal acceleration -  take 1/2 second to reach maxdx
			ACCEL   	= 5,          			//I'm too lazy to work out the physics so I'm just using fixed values for now
			FRICTION	= MAXDX * 6,          	// horizontal friction     -  take 1/6 second to stop from maxdx
			JUMP    	= METER * 1500;       	// (a large) instantaneous jump impulse
			KEY     	= { SPACE: 32, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40 };
			

		var canvas  	= document.getElementById('levelCanvas'),
			ctx     	= canvas.getContext('2d'),
			width   	= canvas.width  = MAP.tileX * TILE,
			height  	= canvas.height = MAP.tileY * TILE;	
		
			
		var t2p      	= function(t)     {return t*TILE;                  },
			p2t      	= function(p)     {return Math.floor(p/TILE);      },
			cell     	= function(x,y)   {return tcell(p2t(x),p2t(y));    },
			tcell    	= function(tx,ty) {return cells[tx + (ty*MAP.tw)]; };
		
		var floor_00 		= document.getElementById('floor_tile_00');
		var floor_01 		= document.getElementById('floor_tile_01');
		var hitbox 			= document.getElementById('hit_box');
		var playerImage 	= document.getElementById('deano');
		var playerWalk 		= document.getElementById('deano_walk');
		var badAppleWalk 	= document.getElementById('crab_apple');
		var coinImage 		= document.getElementById('coin');
		var deadImage 		= document.getElementById('dead');
		var mountains 		= document.getElementById('mountains');
		var hills 			= document.getElementById('hills');
		var sky 			= document.getElementById('sky');
		var cloud 			= document.getElementById('cloud');
		var apple 			= document.getElementById('apple');
		var santa_head_up 	= document.getElementById('santa_head_up');
		var santa_torso_up 	= document.getElementById('santa_torso_up');
		var santa_arms_up 	= document.getElementById('santa_arms_up');
		var santa_corner 	= document.getElementById('santa_corner');
		var santa_feet_up 	= document.getElementById('santa_feet_up');
		var log_tile 		= document.getElementById('log_tile');
		var board_tile 		= document.getElementById('board_tile');
		var level000 		= document.getElementById('level000');
		var coincount		= 0;
		var frameDelay 		= 0;
		var levelX 			= 0;
		var cloudX 			= 1024;
		
		var player 			= {	goalMet:true, x:[], y:[], moving:false, face:"left", length:3, alive:true,frame:0, height:64, width:32, jump:false, fall: false};
		var santa			= {image:coin, x:1, y:1, length:2, alive:true};
		var clouds 			= {x:0,y:0,speed:10};

		var level001 = [
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,02,-2,02,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,-2,02,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-1,02,-2,02,02,02,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-1,-2,-2,-2,-2,-2,02],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,02,02,-2,02],
			[00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,02,-2,02],
			[00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,02,-2,02],
			[00,00,00,00,00,00,00,00,00,00,00,02,02,-2,02,02,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,02,-2,02],
			[00,00,02,-2,02,00,00,00,00,00,02,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,02,-2,02],
			[00,02,02,-2,02,02,00,00,00,02,-2,-2,-2,-2,02,-2,-2,02,00,00,00,00,00,02,-2,-2,02,-2,-2,02,-2,02],
			[00,02,-1,-2,-2,02,00,00,00,02,-1,-2,-2,-2,02,-2,-2,02,00,00,00,00,00,02,-2,-2,02,-2,-2,02,-2,02],
			[00,02,-2,02,-2,02,02,00,00,02,-2,-2,02,-2,02,-2,-2,02,00,00,00,00,00,02,02,02,02,-2,-2,-1,-2,02],
			[00,02,-2,-2,-2,02,02,02,00,02,-1,-2,-2,-2,02,-1,-1,02,00,00,00,00,00,02,02,02,02,-2,02,02,-2,02],
			[01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,-2,01]
		];		

		var level002 = [
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,-2,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,00,02,02,-2,-1,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,00,02,02,02,-2,-2,-1,02,00,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,00,02,02,02,02,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,-2,-1,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-1,-1,-2,-2,-2,-2,-2,02,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,02,02,02,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,00,00,00,00,00,00,00,00,00,02,-2,-2,-2,-2,-2,-2,-2,-2,-2,02,00,00,00,00,00,00,00,00,00,00,00],
			[00,01,00,01,00,01,00,01,00,01,02,-1,-2,-2,01,-2,01,-2,-2,-1,02,00,00,00,00,00,00,00,00,00,00,00],
			[01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01]
		];

		
		var currentLevel = new Array();
		
		level000.crossOrigin = "anonymous";
		
		function loadLevel(inputImage){
			inputImage.crossOrigin = "anonymous";
			inputImage.onload = function(){
				ctx.drawImage(inputImage, 0,0);
			};
			var imgData = ctx.getImageData(0, 0, 20, 32);
					
			console.log(imgData.data);
			
			
			var levelToReturn = new Array();
			for(i=0;i<20;i++){
				levelToReturn[i] = new Array();
				for(j=0;j<32;j++){
					r = imgData.data[i*j];
					g = imgData.data[i*j+1];
					b = imgData.data[i*j+2];
					a = imgData.data[i*j+3];
					//levelToReturn[i][j] = imgData.data[i*32+j*i];
					levelToReturn[i][j] = 0;
				};
			};
				
			return levelToReturn;
		};
		
		
					
		var levelXSize 		= TILE;

				
		if (!window.requestAnimationFrame) {
			window.requestAnimationFrame = window.webkitRequestAnimationFrame || 
				window.mozRequestAnimationFrame    || 
				window.oRequestAnimationFrame      || 
				window.msRequestAnimationFrame     || 
				function(callback, element) {
					window.setTimeout(callback, 1000 / 60);
			}
		}
		

		
		function initPlayer(){
			//player.x = 3 * TILE;
			//player.y = 14 * TILE;
			
			for(i=0;i<player.length;i++){
				player.x[i] = 8;
				player.y[i] = i;
			};
			
			
			
		};
		
		initPlayer();
		
		function drawTile(sourceImage, x, y){
			if(sourceImage.complete){
				ctx.drawImage(sourceImage, x, y);
			}else{
				ctx.fillStyle = COLOR.PINK;
				ctx.fillRect(x, y, TILE, TILE);
			}
		};
		
		function updateEntity(entity, ctx){
			if(entity.y > height){
				entity.alive = false;
			};
			
			if(entity.alive){
				if(entity === player){
					movePlayer();
				};
				
				if(entity.moving){
					if(entity.frame<entity.frameCount){
						if(getAnimStep())
							entity.frame++;
					}else{
						entity.frame=0;
					};
				}else{
					entity.frame=0;
				};
				
				
				
				switch(entity.face){
					case "left":	
					case "right":	
					case "down":	
					case "up":
						drawPlayer();
						//for(i=0;i<entity.length;i++){
						//	ctx.drawImage(entity.image, entity.width*entity.frame,0,entity.width,entity.height,entity.x[i]*32,entity.y[i]*32,entity.width,entity.height);
						//};
						break;									
				};
			};
		};	
				
		function drawPlayer(){
			for(i=player.length-1;i>=0;i--){
				switch(i){
					
					//head
					case 0:
						//rightway up
						if(player.y[1] === player.y[i]+1){
							ctx.drawImage(santa_head_up, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);	
							
							break;
						}
						
						//upside down
						if(player.y[1] === player.y[i]-1){
							//ctx.drawImage(santa_head_up, player.width*player.frame,0,player.width,player.height,player.x[i]*32,player.y[i]*32,player.width,player.height);
							//mirrorImage(ctx, entity, true, false, entity.frame);
						
							flipImage(santa_head_up, ctx, 'down', t2p(player.x[i]),t2p(player.y[i]));
							break;
						}
						
						//face left
						if(player.x[1] === player.x[i]+1){
							//rotateImage(santa_head_up, player.x[i]*32, player.y[i]*32, 1, 45);
							flipImage(santa_head_up, ctx, 'left', t2p(player.x[i]),t2p(player.y[i]));
							break;
						}

						//face right
						if(player.x[1] === player.x[i]-1){
							//rotateImage(santa_head_up, player.x[i]*32, player.y[i]*32, 1, 45);
							flipImage(santa_head_up, ctx, 'right', t2p(player.x[i]),t2p(player.y[i]));
							break;
						}

						//drawTile(santa_head_up, player.x[i], player.y[i]*32);
						break;
						
					//feet
					case player.length - 1:
						//upside down
						if(player.y[i-1] === player.y[i]+1){
							//ctx.drawImage(santa_head_up, player.width*player.frame,0,player.width,player.height,player.x[i]*32,player.y[i]*32,player.width,player.height);
							//mirrorImage(ctx, entity, true, false, entity.frame);
							flipImage(santa_feet_up, ctx, 'down', t2p(player.x[i]),t2p(player.y[i]));
							break;
						}
						
						//right
						if(player.x[i-1] === player.x[i]+1){
							flipImage(santa_feet_up, ctx, 'right', player.x[i]*32,player.y[i]*32);
							break;
						};
						
						//left
						if(player.x[i-1] === player.x[i]-1){
							flipImage(santa_feet_up, ctx, 'left', player.x[i]*32,player.y[i]*32);
							break;
						};
												
						ctx.drawImage(santa_feet_up, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);
						//drawTile(santa_feet_up, player.x[i], player.y[i]);
						break;
					//torso
					default:
						let isVertical 		= false;
						let isHorizontal 	= false;
						let isCorner 		= false;

						let isArmSegment	= i===Math.floor(player.length/4) || 1 ? true:false;
						//we need to check if this is a corner piece
						//first check if it connects the trailing and leading pieces vertically
						if(player.x[i-1] == player.x[i] && player.x[i+1] == player.x[i]){
							isVertical = true;
						}
						
						//then check if it connects them horizontally
						if(player.y[i-1] == player.y[i] && player.y[i+1] == player.y[i]){
							isHorizontal = true;
						}
						
						//if it doesn't then it's a corner piece
						isCorner = !isVertical && !isHorizontal ? true:false;
						
						if(isHorizontal){
							flipImage(santa_torso_up, ctx, 'right', t2p(player.x[i]),t2p(player.y[i]));
							if(isArmSegment)
								flipImage(santa_arms_up, ctx, 'right', t2p(player.x[i]), t2p(player.y[i]));
							break;
						};
						
						if(isCorner){
								  let above 	= false;
								  let below 	= false;
								  let left 	= false;
								  let right 	= false;

								  //console.log("y[i]-1: " + (player.y[i]-1));
								  //console.log("y[i-1]: " + (player.y[i-1]));
								  //console.log(x0,y,y3	

								  //check if the prev/next snake segment is above
								  let tileX = player.x[i];
								  let tileY = player.y[i];

								  //ABOVE
								  if(tileY - 1 === player.y[i-1] && tileX === player.x[i-1])
										  above = true; //head above current segment
								  if(tileY - 1 === player.y[i+1] && tileX === player.x[i+1])
										  above = true; //feet above current segment
								  
								  //BELOW	
								  if(tileY + 1 === player.y[i-1] && tileX === player.x[i-1])
										  below = true; //head below current segment
								  if(tileY + 1 === player.y[i+1] && tileX === player.x[i+1])
										  below = true; //feet below current segment
								  
								  //LEFT
								  if(tileX - 1 === player.x[i-1] && tileY === player.y[i-1])
									  left = true; // console.log("head left of current segment");
								  
								  if(tileX - 1 === player.x[i+1] && tileY === player.y[i+1])
									  left = true; // console.log("head left of current segment");
		  i
								  //RIGHT
								  if(tileX + 1 === player.x[i-1] && tileY === player.y[i-1])
									  right = true; // console.log("head left of current segment");
								  
								  if(tileX + 1 === player.x[i+1] && tileY === player.y[i+1])
									  right = true; // console.log("head left of current segment");

								  ////if(locations != ("top:"+top+", bottom:"+bottom+", left:"+left+", right:"+right))
								  //console.log("i:"+i+", above:"+above+", below:"+below+", left:"+left+", right:"+right);

							if(above && right){
								//this is top right
								flipImage(santa_corner, ctx, 'right', t2p(player.x[i]),t2p(player.y[i]));
								flipImage(santa_arms_up, ctx, 'right', t2p(player.x[i]),t2p(player.y[i]));
								break;
							}
						
							if(below && right){
								flipImage(santa_corner, ctx, 'down', t2p(player.x[i]),t2p(player.y[i]));
								flipImage(santa_arms_up, ctx, 'down', t2p(player.x[i]),t2p(player.y[i]));
								break;
							}
							if(above && left){
								ctx.drawImage(santa_corner, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);
								ctx.drawImage(santa_arms_up, player.width*player.frame,0,player.width+15,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);
								break;
							}
							if(below && left){
								flipImage(santa_corner, ctx, 'left', t2p(player.x[i]),t2p(player.y[i]));
								flipImage(santa_arms_up, ctx, 'left', t2p(player.x[i]),t2p(player.y[i]));
								break;
							}
						}
												
						ctx.drawImage(santa_torso_up, player.width*player.frame,0,player.width,player.height,t2p(player.x[i]),t2p(player.y[i]),player.width,player.height);

					if(isArmSegment)
						ctx.drawImage(santa_arms_up, player.width*player.frame,0,47,player.height,t2p(player.x[i]),t2p(player.y[i])-10,player.width,player.height);	
						//drawTile(santa_torso_up, player.x[i], player.y[i]);
						break;
				};
			};

		};
		
		function flipImage(image, ctx, flip, x, y) {
				
			ctx.save(); // Save the current state
			
			switch(flip){
				case 'right':
					rotation = 90;
					ctx.translate(t2p(1),t2p(0));
					rotation = rotation / 180 * Math.PI;
					ctx.rotate(rotation);
					ctx.drawImage(image, y, x*-1, TILE, TILE); // draw the image
					break;
				case 'left':
					rotation = 270;
					ctx.translate(t2p(0),t2p(1));
					rotation = rotation / 180 * Math.PI;
					ctx.rotate(rotation);
					ctx.drawImage(image, y*-1, x, TILE, TILE); // draw the image
					break;
				case 'down':
					var scaleH =  1; // Set horizontal scale to -1 if flip horizontal
					var	scaleV = -1; // Set verical scale to -1 if flip vertical
					var posX = t2p(-1) ; // Set x position to -100% if flip horizontal 
					var posY = t2p(-1);// Set y position to -100% if flip vertical
					ctx.scale(-1, -1); // Set scale to flip the image
			      ctx.drawImage(image, posX - x, posY - y, TILE, TILE); // draw the image
					break;

			};
					
			
				//ctx.scale(scaleH, scaleV); // Set scale to flip the image
				//ctx.drawImage(image,posX + x, posY - y, TILE, TILE); // draw the image
			//ctx.drawImage(image, player.width,0,32,32,player.x[0]*32,player.y[0]*32,player.width,player.height);
			ctx.restore(); // Restore the last saved state
		};

		function mirrorImage(ctx, entity, horizontal, vertical, frame){
		
			var image = entity.image;
			let x = entity.x;
			let y = entity.y;
			
			ctx.save();  // save the current canvas state
			
			var a = horizontal ? -1 : 1; // set the direction of x axis
			var b = 0; 
			var c = 0;
			var d = vertical ? -1 : 1; //// set the direction of y axis
//			var e = x + horizontal ? image.width : 0; // set the x origin
//			var f = y + vertical ? image.height : 0 ; // set the y origin
			var e = horizontal ? x + entity.width : x; // set the x origin
			var f = vertical   ? y + entity.height: y; // set the y origin
			
			
			ctx.setTransform(a,b,c,d,e,f);
			//ctx.drawImage(image,0,0);
			ctx.drawImage(image, entity.width*frame,0,entity.width,entity.height,0,0,entity.width,entity.height);
			ctx.restore(); // restore the state as it was when this function was called
		};		
	
		function timestamp() {
		  if (window.performance && window.performance.now)
			return window.performance.now();
		  else
			return new Date().getTime();
		};
		
		var fps  = 60,
			step = 1/fps,
			dt   = 0,
			now, last = timestamp(),
			cells = [];
			
		function bound(x, min, max) {
			return Math.max(min, Math.min(max, x));
		};			

		function frame() {
		  now = timestamp();
		  dt = dt + Math.min(1, (now - last) / 1000);
		  while(dt > step) {
			dt = dt - step;
			update(step);
		  }
		  last = now;
		  requestAnimationFrame(frame, canvas);
		}

		frame(); // start the first frame
		
		function invertNumber(numberToInvert){
			return numberToInvert * -1;
		};	

		function drawLevel(ctx){
			//These two variable set the portions of the screen that trigger scrolling of the level
			var upperBound = TILE * 22;
			var lowerBound = TILE * 10;
			
			//OPEN| These chunks sets the level X position and player X position for scrolling
			if(player.x > upperBound && levelX < levelXSize){
				levelX-=ACCEL;
				player.x = upperBound;
			};

			if(player.x < lowerBound && levelX < 0){
				levelX+=ACCEL;
				player.x = lowerBound;
			};
			//CLOSE|
			
			arrayX = p2t(invertNumber(levelX));

			//Draw Sky
			for(y=0;y<MAP.tileY;y++){
				for(x=0;x<MAP.tileX + 2;x++){
					if(y >= 0 && y < height){ 
						let drawX = levelX +t2p(x+arrayX);
						
						//levelX+((x+arrayX)*8)
						
						let drawY = t2p(y);
						
						//console.log(p2t(x + levelX));
						let character = currentLevel[y][x];
						switch(character){
							case -2:
								drawTile(board_tile, drawX, drawY);
								break;
								
							default:
								ctx.fillStyle = COLOR.SKY;
								ctx.fillRect(drawX, drawY, TILE, TILE);
								break;
						
						};
					};
				};
			};
			
			drawTile(sky, 0, 0);
			
			//Draw Background (This is a mess)
			//TODO make this bit sane
			
			var bg_width = 5000;
			
			//drawTile(mountains, levelX/4, 0);
			//drawTile(mountains, levelX/4+bg_width, 0);
			//drawTile(mountains, levelX/4+bg_width+bg_width, 0);
			//drawTile(hills, levelX/1.5, 0);
			//drawTile(hills, levelX/1.5+bg_width, 0);
			//drawTile(hills, levelX/1.5+bg_width+bg_width, 0);
			//drawTile(hills, levelX/1.5+bg_width+bg_width+bg_width, 0);
			//drawTile(hills, levelX/1.5+bg_width+bg_width+bg_width+bg_width, 0);
			//
			//
			//drawRain(ctx);

			//Draw Clouds
			//drawTile(cloud, --cloudX, 20);
			if(cloudX < -766){
				cloudX = 1300;
			};
			
			player.goalMet = true;
			
			//Draw Foreground
			for(y=0;y<MAP.tileY;y++){
				for(x=0;x<MAP.tileX + 2;x++){
					if(y >= 0 && y < height){ 
						let drawX = levelX +t2p(x+arrayX);
						
						//levelX+((x+arrayX)*8)
						
						let drawY = t2p(y);
						
						//console.log(p2t(x + levelX));
						let character = currentLevel[y][x+arrayX];
						switch(character){
							//default:
							//	ctx.fillStyle = COLOR.SKY;
							//	ctx.fillRect(drawX, drawY, TILE, TILE);
							//	break;
							case 1:
								if(drawY > 0 && currentLevel[y-1][x+arrayX] === 0 ){
									drawTile(floor_00, drawX, drawY);
								}else{
									drawTile(floor_01, drawX, drawY);
								};
								break;
							case 2:								
								drawTile(board_tile, drawX, drawY);
								drawTile(log_tile, drawX, drawY);
								break;
							case -2:
								drawTile(board_tile, drawX, drawY);
								break;
							case -1:
								drawTile(board_tile, drawX, drawY);
								drawTile(apple, drawX, drawY);
								player.goalMet = false;
								break;
							case -3:
								ctx.fillStyle = COLOR.SKY;
								ctx.fillRect(drawX, drawY, TILE, TILE);
								drawCoin(ctx, drawX, drawY);
								break;
							case -9:
								drawTile(level000, drawX, drawY);
								break;
						};
					};
				};
			};
			
			if(player.goalMet){
				currentLevel[2][13] = -9;
//				drawTile(apple, t2p(13), t2p();
			};
		};

		var inLMS = true;
		
		try{ trivPageScope; }
		catch(e) {
			if(e.name == "ReferenceError") {
				inLMS = false;
				console.log("not in lectora");
				document.addEventListener('keydown', function(ev) { return onkey(ev, ev.keyCode, true);  }, false);
				document.addEventListener('keyup',   function(ev) { return onkey(ev, ev.keyCode, false); }, false);
			};
		};
			
		if(inLMS){
			console.log("in lectora");
			var thePage = document.getElementById('pageDIV');
			console.log("does the page work? = " + thePage);
			thePage.addEventListener('keydown', function(ev) { return onkey(ev, ev.keyCode, true);  }, false);
			thePage.addEventListener('keyup',   function(ev) { return onkey(ev, ev.keyCode, false); }, false);

		};
		
		function onkey(ev, key, down) {
			if(down){
				switch(key) {
					case KEY.LEFT:  player.moving = true; player.face = "left";	/*console.log("you pressed the left key, player x:"+player.x)*/	;break;
					case KEY.RIGHT: player.moving = true; player.face = "right";/*console.log("you pressed the right key, player x:"+player.x)*/;break;
					case KEY.UP: 	player.moving = true; player.face = "up";	/*console.log("you pressed the left key, player x:"+player.x)*/	;break;
					case KEY.DOWN: 	player.moving = true; player.face = "down";	/*console.log("you pressed the right key, player x:"+player.x)*/;break;
				};
			}else{
				player.moving =  false;
			};
		};
				
		function update(dt){
			//drawNoise();
			currentLevel = loadLevel(level000);
			//drawLevel(ctx, dt);
			updateEntity(player, ctx)
			//for(i=0;i<baddies.length;i++)
			//	updateEntity(baddies[i], ctx)
		};


		function aldronKeyUp(){
			player.moving = false;
		};
		
		function isFalling(){
			//Set falling to true, then check for any supporting tiles
			player.falling = true;
			
			a
			//if there are any tiles under the snake then it isn't falling
			for(i=0;i<player.length;i++){
				//console.log(player.x[i]);
				//console.log(player.y[i] + 1);
				if(currentLevel[player.y[i] + 1][player.x[i]] > 0){
					player.falling=false;
				};
				
			};
			
			if(player.falling){
				for(i=0;i<player.length;i++){
					player.y[i]+=1;
				};
			};
			
			return player.falling;
		
		};
		
		function tail(){
			for(i=player.length+1;i>0;i--){
				player.x[i] = player.x[i-1];
				player.y[i] = player.y[i-1];
			};
		};

		function isTileTail(y,x){
			for(i=player.length-1;i>0;i--){
				if( player.x[i] === x && player.y[i] === y)
					return true;
			};
			return false;
		};
		
		function playerCanMove(){
			switch(player.face){
				case "left":
					if(currentLevel[player.y[0]][player.x[0] - 1] < 1 && !isTileTail(player.y[0], player.x[0] - 1)){
						return true;
					};
					break;
				case "right":	
					if(currentLevel[player.y[0]][player.x[0] + 1] < 1 && !isTileTail(player.y[0], player.x[0] + 1)){
						return true;
					}; 
					break;
				case "down":
					if(currentLevel[player.y[0]+1][player.x[0]] < 1 && !isTileTail(player.y[0]+1, player.x[0])){
						return true;
					};
					break;
				case "up":	
					if(player.y[0]>0){	
						if(currentLevel[player.y[0]-1][player.x[0]] < 1 && !isTileTail(player.y[0]-1, player.x[0])){
							return true;
						};
					};
					break;
			};
			return false;
			
		};
		
		function movePlayer(){	

			isFalling();
		
			if(player.moving &&  !isFalling()){


				switch(player.face){
					case "left":
						if(playerCanMove()){
							tail();
							player.x[0]-=1; 
						};
						break;
					case "right":	
						if(playerCanMove()){
							tail();
							player.x[0]+=1;							
						}; 
						break;
					case "down":
						if(playerCanMove()){
							tail();player.y[0]+=1; break;
						};
					case "up":
						if(playerCanMove()){
							tail();player.y[0]-=1; break;
						};
				};
				
				
				
				player.moving = false;
			};
			
			//Collect apples
			if(currentLevel[player.y[0]][player.x[0]] === -1 || currentLevel[player.y[0]][player.x[0]] === -9){
				player.length+=1;
				currentLevel[player.y[0]][player.x[0]] = -2;
			};
			
		};
		
		
		</script>
	</body>
</html>
